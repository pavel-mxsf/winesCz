'use strict';
var xlsReader = require("xlsReader");
var q = require('q');

function parseXlsFile(filename) {
    var deferred = q.defer();
    xlsReader(filename).then(parseXlsObject).done(function(val){deferred.resolve(val)});
    return deferred.promise;
}

function parseXlsObject(obj) {
    var output = [];
    for (var sheet in obj.Sheets) {
        if (obj.Sheets.hasOwnProperty(sheet)) {
            var accu = [];
            for (var cell in obj.Sheets[sheet]) {
                if (obj.Sheets[sheet].hasOwnProperty(cell)) {

                    var cellPosition = parsePosition(cell);
                    if (cellPosition != undefined) {
                        if (typeof accu[cellPosition.row] == 'undefined') {
                            accu[cellPosition.row] = {};
                        }
                        accu[cellPosition.row][cellPosition.column] = obj.Sheets[sheet][cell];
                    }
                }
            }
            accu.forEach(function(row){
                if (validateRow(row)) {
                    output.push(rowToObject(row));
                }
            });
        }
    }
    return q.all(output);
}

function parsePosition(pos) {
    var reg = /([A-Z])([0-9]*)/;
    var regres = reg.exec(pos);
    if (regres && regres.length === 3 && regres[2]) {
        return {row: parseInt(regres[2],10), column: regres[1] }
    }
    else return undefined;
}

function validateRow(row) {
    return (checkProperties(row, ['B','C','D','E', 'F']) && !isHeaderOrFooter(row));
}

function checkProperties(obj, props) {
    var ret = true;
    props.forEach(function(p) {if (!obj.hasOwnProperty(p)) {ret = false;}});
    return ret;
}

function isHeaderOrFooter(row) {
    return isNaN(parseInt(row.E.v,10));
}

function rowToObject(row) {
    var prod = row.F.v.split(/, (.+)?/);
    var fullName = row.A ? row.A.v : 'unknown';
    var nameParsing = fullName.split(/, /);
    var wineProps = {
        variety: '',
        type: '',
        grade: ''
    };
    if (nameParsing.length===1) {wineProps.variety = nameParsing[0]}
    else if (nameParsing.length===2) {wineProps.variety = nameParsing[0]; wineProps.grade = nameParsing[1]}
    else if (nameParsing.length===3) {wineProps.type = nameParsing[0].toLowerCase(); wineProps.variety = nameParsing[1]; wineProps.grade = nameParsing[2]}

    var reg = row.D.v.split(/, (.+)?/);

    return {
        vintage: parseInt(row.E.v, 10),
        producer: prod[1],
        producerNo: prod[0],
        region: reg[0],
        subregion: reg[1],
        regNum: row.B.v,
        batch: row.C.v,
        fullName: fullName,
        variety: wineProps.variety,
        type: wineProps.type,
        grade: wineProps.grade
    };
}

module.exports = {
    parseXlsFile:parseXlsFile,
    private:{
        parsePosition: parsePosition,
        validateRow: validateRow,
        rowToObject: rowToObject
    }
};