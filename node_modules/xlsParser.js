'use strict';
var xlsReader = require("xlsReader");
var q = require('q');

function parseXlsFile(filename) {
    var deferred = q.defer();
    xlsReader(filename).then(parseXlsObject).done(function(val){deferred.resolve(val)});
    return deferred.promise;
}

function parseXlsObject(obj) {
    var output = [];
    for (var sheet in obj.Sheets) {
        if (obj.Sheets.hasOwnProperty(sheet)) {
            var accu = [];
            for (var cell in obj.Sheets[sheet]) {
                if (obj.Sheets[sheet].hasOwnProperty(cell)) {

                    var cellPosition = parsePosition(cell);
                    if (cellPosition != undefined) {
                        if (typeof accu[cellPosition.row] == 'undefined') {
                            accu[cellPosition.row] = {};
                        }
                        accu[cellPosition.row][cellPosition.column] = obj.Sheets[sheet][cell];
                    }
                }
            }
            accu.forEach(function(row){
                if (validateRow(row)) {
                    output.push(rowToObject(row));
                }
            });
        }
    }
    return q.all(output);
}

function parsePosition(pos) {
    var reg = /([A-Z])([0-9]*)/;
    var regres = reg.exec(pos);
    if (regres && regres.length === 3 && regres[2]) {
        return {row: parseInt(regres[2],10), column: regres[1] }
    }
    else return undefined;
}

function validateRow(row) {
    return (checkProperties(row, ['B','C','D','E', 'F']) && !isHeaderOrFooter(row));
}

function checkProperties(obj, props) {
    var ret = true;
    props.forEach(function(p) {if (!obj.hasOwnProperty(p)) {ret = false;}});
    return ret;
}

function isHeaderOrFooter(row) {
    return isNaN(parseInt(row.E.v,10));
}

function stripAccents(s, c){
    var $acc, $str, o, r, i

    if (typeof(c)=='undefined'){
        c = -1;
    }

    $acc =	'É	Ê	Ë	š	Ì	Í	ƒ	œ	µ	Î	Ï	ž	Ð	Ÿ	Ñ	Ò	Ó	Ô	Š	£	Õ	Ö	Œ	¥	Ø	Ž	§	À	Ù	Á	Ú	Â	Û	Ã	Ü	Ä	Ý	';
    $str =	'E	E	E	s	I	I	f	o	m	I	I	z	D	Y	N	O	O	O	S	L	O	O	O	Y	O	Z	S	A	U	A	U	A	U	A	U	A	Y	';
    $acc+=	'Å	Æ	ß	Ç	à	È	á	â	û	Ĕ	ĭ	ņ	ş	Ÿ	ã	ü	ĕ	Į	Ň	Š	Ź	ä	ý	Ė	į	ň	š	ź	å	þ	ė	İ	ŉ	Ţ	Ż	æ	ÿ	';
    $str+=	'A	A	S	C	a	E	a	a	u	E	i	n	s	Y	a	u	e	I	N	S	Z	a	y	E	i	n	s	z	a	p	e	I	n	T	Z	a	y	';
    $acc+=	'Ę	ı	Ŋ	ţ	ż	ç	Ā	ę	Ĳ	ŋ	Ť	Ž	è	ā	Ě	ĳ	Ō	ť	ž	é	Ă	ě	Ĵ	ō	Ŧ	ſ	ê	ă	Ĝ	ĵ	Ŏ	ŧ	ë	Ą	ĝ	Ķ	ŏ	';
    $str+=	'E	l	n	t	z	c	A	e	I	n	T	Z	e	a	E	i	O	t	z	e	A	e	J	o	T	i	e	a	G	j	O	t	e	A	g	K	o	';
    $acc+=	'Ũ	ì	ą	Ğ	ķ	Ő	ũ	í	Ć	ğ	ĸ	ő	Ū	î	ć	Ġ	Ĺ	Œ	ū	ï	Ĉ	ġ	ĺ	œ	Ŭ	ð	ĉ	Ģ	Ļ	Ŕ	ŭ	ñ	Ċ	ģ	ļ	ŕ	Ů	';
    $str+=	'U	i	a	G	k	O	u	i	C	g	k	o	U	i	c	G	L	O	u	i	C	g	l	o	U	o	c	G	L	R	u	n	C	g	l	r	U	';
    $acc+=	'ò	ċ	Ĥ	Ľ	Ŗ	ů	ó	Č	ĥ	ľ	ŗ	Ű	ô	č	Ħ	Ŀ	Ř	ű	õ	Ď	ħ	ŀ	ř	Ų	ö	ď	Ĩ	Ł	Ś	ų	Đ	ĩ	ł	ś	Ŵ	ø	đ	';
    $str+=	'o	c	H	L	R	u	o	C	h	l	r	U	o	c	H	L	R	u	o	D	h	l	r	U	o	d	I	L	S	c	D	i	l	s	W	o	d	';
    $acc+=	'Ī	Ń	Ŝ	ŵ	ù	Ē	ī	ń	ŝ	Ŷ	Ə	ú	ē	Ĭ	Ņ	Ş	ŷ';
    $str+=	'I	N	S	w	u	E	i	n	s	Y	e	u	e	I	N	S	y';

    o = '';

    var ta = $acc.split("\t");
    var ts = $str.split("\t");

    for (i = 0; i < ta.length; i++){
        r = new RegExp('[' + ta[i] + ']', 'g');
        s = s.replace(r, ts[i]);
    }

    s = s.replace(/[^a-zA-Z0-9_-]/gi, o);

    s = s.replace(/[_]+/, '_');
    s = s.replace(/^_*(.*?)_*$/gi, '$1')

    if(c == -1){
        return s.toLowerCase();
    }else if(c == 1){
        return s.toUpperCase();
    }else{
        return s;
    }
}

function rowToObject(row) {
    var prod = row.F.v.split(/, (.+)?/);
    var fullName = row.A ? row.A.v : 'unknown';
    var nameParsing = fullName.split(/, /);
    var wineProps = {
        variety: '',
        type: '',
        grade: ''
    };
    if (nameParsing.length===1) {wineProps.variety = nameParsing[0]}
    else if (nameParsing.length===2) {wineProps.variety = nameParsing[0]; wineProps.grade = nameParsing[1]}
    else if (nameParsing.length===3) {wineProps.type = nameParsing[0].toLowerCase(); wineProps.variety = nameParsing[1]; wineProps.grade = nameParsing[2]}

    var reg = row.D.v.split(/, (.+)?/);

    return {
        vintage: parseInt(row.E.v, 10),
        producer: prod[1],
        producerId: parseInt(prod[0],10),
        region: reg[0],
        subregion: reg[1],
        regNum: row.B.v,
        batch: row.C.v,
        fullName: fullName,
        search: stripAccents(fullName, -1) + stripAccents(prod[1], -1),
        variety: wineProps.variety,
        type: wineProps.type,
        grade: wineProps.grade
    };
}

module.exports = {
    parseXlsFile:parseXlsFile,
    private:{
        parsePosition: parsePosition,
        validateRow: validateRow,
        rowToObject: rowToObject
    }
};